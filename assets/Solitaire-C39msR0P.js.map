{"version":3,"mappings":"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","names":["SUITS","RANKS","getCardValue","rank","getSuitColor","suit","getSuitSymbol","Solitaire","gameState","setGameState","useState","selectedCard","setSelectedCard","history","setHistory","future","setFuture","isDealing","setIsDealing","initializeGame","useCallback","createDeck","d","bestDeck","foundSolvable","attempts","MAX_ATTEMPTS","shuffle","i","j","isSolvable","__vitePreload","candidate","newDeck","newTableau","deckIndex","card","newStock","useEffect","saveHistory","prev","undo","previousState","redo","nextState","handleKeyDown","canMoveToFoundation","pile","topCard","canMoveToTableau","columnIndex","column","handleStockClick","c","handleCardClick","sources","targetColIndex","targetColumn","handleMoveAttempt","handleDoubleClick","source","directMove","targetSuit","newGameState","col","movedCards","colIdx","acc","handleEmptyTableauClick","colIndex","handleFoundationClick","cardsToMove","executeMove","target","cardToMove","handleDragStart","e","handleDragOver","handleDrop","sourceData","executeDragMove","renderCard","index","pileLength","isSelected","topStyle","spacing","jsxs","jsx","idx"],"ignoreList":[],"sources":["../../src/types/solitaire.ts","../../src/components/Solitaire.tsx"],"sourcesContent":["export type Suit = 'hearts' | 'diamonds' | 'clubs' | 'spades';\nexport type Color = 'red' | 'black';\nexport type Rank = 'A' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '10' | 'J' | 'Q' | 'K';\n\nexport interface Card {\n    id: string;\n    suit: Suit;\n    rank: Rank;\n    color: Color;\n    faceUp: boolean;\n}\n\nexport interface GameState {\n    stock: Card[];\n    waste: Card[];\n    foundations: { [key in Suit]: Card[] };\n    tableau: Card[][];\n    score: number;\n    moves: number;\n    status: 'playing' | 'won';\n}\n\nexport const SUITS: Suit[] = ['hearts', 'diamonds', 'clubs', 'spades'];\nexport const RANKS: Rank[] = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];\n\nexport const getCardValue = (rank: Rank): number => {\n    return RANKS.indexOf(rank) + 1;\n};\n\nexport const getSuitColor = (suit: Suit): Color => {\n    return suit === 'hearts' || suit === 'diamonds' ? 'red' : 'black';\n};\n","\nimport React, { useState, useEffect, useCallback } from 'react';\nimport './Solitaire.css';\n\nimport {\n  Suit, Card, GameState,\n  SUITS, RANKS, getCardValue, getSuitColor,\n  // getSuitSymbol is local UI only, keep it or move it? keep it here for now or duplicate if needed by solver.\n  // Solver doesn't need symbol.\n} from '../types/solitaire';\n\nconst getSuitSymbol = (suit: Suit): string => {\n  switch (suit) {\n    case 'hearts': return '♥';\n    case 'diamonds': return '♦';\n    case 'clubs': return '♣';\n    case 'spades': return '♠';\n  }\n};\n\nconst Solitaire: React.FC = () => {\n  const [gameState, setGameState] = useState<GameState>({\n    stock: [],\n    waste: [],\n    foundations: {\n      hearts: [],\n      diamonds: [],\n      clubs: [],\n      spades: []\n    },\n    tableau: [],\n    score: 0,\n    moves: 0,\n    status: 'playing'\n  });\n\n  const [selectedCard, setSelectedCard] = useState<{ pile: string, index: number, card: Card } | null>(null);\n\n  // History State\n  const [history, setHistory] = useState<GameState[]>([]);\n  const [future, setFuture] = useState<GameState[]>([]);\n\n  const [isDealing, setIsDealing] = useState(false);\n\n  // Initialize Game\n  const initializeGame = useCallback(async () => {\n    setIsDealing(true);\n    // Use timeout to allow UI to render \"Dealing...\" state\n    setTimeout(async () => {\n      // Create Deck\n      const createDeck = () => {\n        const d: Card[] = [];\n        SUITS.forEach(suit => {\n          RANKS.forEach(rank => {\n            d.push({\n              id: `${rank}-${suit}`,\n              suit,\n              rank,\n              color: getSuitColor(suit),\n              faceUp: false\n            });\n          });\n        });\n        return d;\n      };\n\n      // Try to find a solvable deck\n      let bestDeck: Card[] = [];\n      let foundSolvable = false;\n      let attempts = 0;\n      const MAX_ATTEMPTS = 5; // Keep it low for speed\n\n      // Helper shuffle\n      const shuffle = (d: Card[]) => {\n        for (let i = d.length - 1; i > 0; i--) {\n          const j = Math.floor(Math.random() * (i + 1));\n          [d[i], d[j]] = [d[j], d[i]];\n        }\n        return d;\n      };\n\n      const { isSolvable } = await import('../utils/solitaireSolver');\n\n      while (!foundSolvable && attempts < MAX_ATTEMPTS) {\n        const candidate = shuffle(createDeck());\n        // Simple heuristic check: prevent 4 aces at bottom of deep piles?\n        // Actually run solver\n        if (isSolvable(candidate)) {\n          bestDeck = candidate;\n          foundSolvable = true;\n          // console.log(\"Found solvable deck in attempt:\", attempts + 1);\n        } else {\n          bestDeck = candidate; // Keep last attempt as fallback\n        }\n        attempts++;\n      }\n\n      const newDeck = bestDeck;\n\n      // Deal to Tableau\n      const newTableau: Card[][] = Array(7).fill([]).map(() => []);\n      let deckIndex = 0;\n\n      for (let i = 0; i < 7; i++) {\n        for (let j = 0; j <= i; j++) {\n          const card = { ...newDeck[deckIndex], faceUp: j === i };\n          newTableau[i].push(card);\n          deckIndex++;\n        }\n      }\n\n      const newStock = newDeck.slice(deckIndex).map(card => ({ ...card, faceUp: false }));\n\n      setGameState({\n        stock: newStock,\n        waste: [],\n        foundations: {\n          hearts: [],\n          diamonds: [],\n          clubs: [],\n          spades: []\n        },\n        tableau: newTableau,\n        score: 0,\n        moves: 0,\n        status: 'playing'\n      });\n      setHistory([]);\n      setFuture([]);\n      setSelectedCard(null);\n      setIsDealing(false);\n    }, 50);\n  }, []);\n\n  useEffect(() => {\n    initializeGame();\n  }, [initializeGame]);\n\n  // Undo/Redo Logic\n  const saveHistory = () => {\n    setHistory(prev => [...prev, gameState]);\n    setFuture([]);\n  };\n\n  const undo = () => {\n    if (history.length === 0) return;\n    const previousState = history[history.length - 1];\n    setFuture(prev => [...prev, gameState]);\n    setGameState(previousState);\n    setHistory(prev => prev.slice(0, -1));\n    setSelectedCard(null);\n  };\n\n  const redo = () => {\n    if (future.length === 0) return;\n    const nextState = future[future.length - 1];\n    setHistory(prev => [...prev, gameState]);\n    setGameState(nextState);\n    setFuture(prev => prev.slice(0, -1));\n    setSelectedCard(null);\n  };\n\n  // Keyboard Shortcuts\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'z') {\n        if (e.shiftKey) {\n          redo();\n        } else {\n          undo();\n        }\n      } else if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'y') {\n        redo();\n      }\n    };\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [history, future, gameState]); // Deps needed for closure state access? \n  // Actually, standard closure trap. It's better to use functional updates or Refs\n  // But since we are calling state setters with prev, undo/redo need access to current history/future arrays.\n  // We should add them to dependency array.\n\n  // Card Movement Logic\n  const canMoveToFoundation = (card: Card, suit: Suit): boolean => {\n    const pile = gameState.foundations[suit];\n    if (card.suit !== suit) return false;\n\n    if (pile.length === 0) {\n      return card.rank === 'A';\n    }\n\n    const topCard = pile[pile.length - 1];\n    return getCardValue(card.rank) === getCardValue(topCard.rank) + 1;\n  };\n\n  const canMoveToTableau = (card: Card, columnIndex: number): boolean => {\n    const column = gameState.tableau[columnIndex];\n\n    // If the column is empty, only a King (Rank 13) can be placed there\n    if (column.length === 0) {\n      return card.rank === 'K';\n    }\n\n    // Otherwise, check standard solitaire rules: alternate color and descending rank\n    const topCard = column[column.length - 1];\n    return topCard.faceUp &&\n      topCard.color !== card.color &&\n      getCardValue(topCard.rank) === getCardValue(card.rank) + 1;\n  };\n\n  // Actions\n  const handleStockClick = () => {\n    saveHistory(); // Save before modifying\n\n    if (gameState.stock.length === 0) {\n      // Recycle waste to stock\n      if (gameState.waste.length === 0) return;\n\n      const newStock = [...gameState.waste].reverse().map(c => ({ ...c, faceUp: false }));\n      setGameState(prev => ({\n        ...prev,\n        stock: newStock,\n        waste: [],\n        moves: prev.moves + 1\n      }));\n    } else {\n      // Draw card\n      const card = { ...gameState.stock[0], faceUp: true };\n      setGameState(prev => ({\n        ...prev,\n        stock: prev.stock.slice(1),\n        waste: [...prev.waste, card],\n        moves: prev.moves + 1\n      }));\n    }\n    setSelectedCard(null);\n  };\n\n  const handleCardClick = (card: Card, sources: { pile: string, index: number }) => {\n    if (!card.faceUp) {\n      // If it's a closed tableau card and it's the top one (exposed), flip it? No, logic handles flipping automatically when top card is removed.\n      // Actually, we need to handle flipping if it's the last card in a tableau column and face down? \n      // Wait, standard solitaire rules: only the top card if exposed (no cards on top) is flipped. \n      // In our data structure, if we move a card, we should check if the new top card needs flipping.\n      return;\n    }\n\n    if (selectedCard) {\n      // Attempt to move selected card to this target\n      // If same card, deselect\n      if (selectedCard.card.id === card.id) {\n        setSelectedCard(null);\n        return;\n      }\n\n      // Check if target is a valid tableau move\n      if (sources.pile.startsWith('tableau')) {\n        const targetColIndex = parseInt(sources.pile.split('-')[1]);\n\n        // We are trying to move 'selectedCard' (could be a stack) onto 'card' (which is at 'targetColIndex')\n        // 'card' must be the top card of that column for this to be a valid click target usually?\n        // Actually, 'card' is just the card clicked. In tableau, can only move to the last card.\n\n        const targetColumn = gameState.tableau[targetColIndex];\n        const targetTopCard = targetColumn[targetColumn.length - 1];\n\n        if (targetTopCard.id === card.id) {\n          handleMoveAttempt(targetColIndex);\n        } else {\n          // Clicked on a card that isn't the top of the pile, so switch selection\n          setSelectedCard({ ...sources, card });\n        }\n      } else {\n        // Clicked on foundation/waste?? switch selection\n        setSelectedCard({ ...sources, card });\n      }\n    } else {\n      // Select logic\n      // Can select from waste (top only)\n      // Can select from tableau (any face up card)\n      // Can select from foundation (top only) - usually allows moving back\n\n      if (sources.pile === 'waste') {\n        // Only last card selectable\n        if (sources.index === gameState.waste.length - 1) {\n          setSelectedCard({ ...sources, card });\n        }\n      } else if (sources.pile.startsWith('tableau')) {\n        setSelectedCard({ ...sources, card });\n      } else if (sources.pile.startsWith('foundation')) {\n        setSelectedCard({ ...sources, card });\n      }\n    }\n  };\n\n  const handleDoubleClick = (card: Card, source: { pile: string, index: number }) => {\n    // Try to move to foundation\n    for (const suit of SUITS) {\n      if (canMoveToFoundation(card, suit)) {\n        setSelectedCard({ card, ...source });\n        // Use setTimeout to allow state update of selection (though we could refactor executeMove to take args directly)\n        // Better: Refactor executeMove to take explicit source/card args or just handle it here directly.\n        // But executeMove relies on selectedCard state.\n        // Let's modify executeMove to optionally take a 'moveOp' object, or just set selection and trigger next render? No, that's racy.\n\n        // To be safe and clean, let's just manually trigger the move logic here tailored for double click\n        // But reuse logic is better.\n        // Let's change executeMove to read from args if provided.\n\n        // Actually, we can just call a direct move helper that doesn't rely on `selectedCard` state for this specific action.\n        directMove(source, suit);\n        return;\n      }\n    }\n  };\n\n  const directMove = (source: { pile: string, index: number }, targetSuit: Suit) => {\n    saveHistory();\n    setGameState(prev => {\n      const newGameState = {\n        ...prev,\n        tableau: prev.tableau.map(col => [...col]),\n        foundations: { ...prev.foundations, [targetSuit]: [...prev.foundations[targetSuit]] },\n        waste: [...prev.waste],\n        stock: [...prev.stock]\n      };\n      // ... logic continues ...\n      let movedCards: Card[] = [];\n\n      // Remove\n      if (source.pile === 'waste') {\n        movedCards = [newGameState.waste.pop()!];\n      } else if (source.pile.startsWith('tableau')) {\n        const colIdx = parseInt(source.pile.split('-')[1]);\n        const col = newGameState.tableau[colIdx];\n        movedCards = col.splice(source.index);\n\n        if (col.length > 0 && !col[col.length - 1].faceUp) {\n          col[col.length - 1].faceUp = true;\n          newGameState.score += 5;\n        }\n      }\n\n      // Add\n      newGameState.foundations[targetSuit].push(movedCards[0]);\n      newGameState.score += 10;\n      newGameState.moves += 1;\n\n      // Win check\n      const foundationCount = Object.values(newGameState.foundations).reduce((acc, pile) => acc + pile.length, 0);\n      if (foundationCount === 52) {\n        newGameState.status = 'won';\n      }\n\n      return newGameState;\n    });\n    setSelectedCard(null); // Clear any selection\n  };\n\n  const handleEmptyTableauClick = (colIndex: number) => {\n    if (selectedCard) {\n      handleMoveAttempt(colIndex);\n    }\n  };\n\n  const handleFoundationClick = (suit: Suit) => {\n    if (selectedCard) {\n      // Move from selectedCard to foundation\n      const pile = selectedCard.pile;\n      let cardsToMove: Card[] = [];\n\n      if (pile === 'waste') {\n        cardsToMove = [selectedCard.card];\n      } else if (pile.startsWith('tableau')) {\n        const colIdx = parseInt(pile.split('-')[1]);\n        const col = gameState.tableau[colIdx];\n        // Can only move one card to foundation at a time\n        if (selectedCard.index === col.length - 1) {\n          cardsToMove = [selectedCard.card];\n        }\n      }\n\n      if (cardsToMove.length === 1) {\n        const card = cardsToMove[0];\n        if (canMoveToFoundation(card, suit)) {\n          executeMove(suit);\n        }\n      }\n    }\n  };\n\n  const executeMove = (target: string | number) => {\n    if (!selectedCard) return;\n    saveHistory();\n\n    setGameState(prev => {\n      const newGameState = {\n        ...prev,\n        tableau: prev.tableau.map(col => [...col]),\n        foundations: {\n          hearts: [...prev.foundations.hearts],\n          diamonds: [...prev.foundations.diamonds],\n          clubs: [...prev.foundations.clubs],\n          spades: [...prev.foundations.spades]\n        },\n        waste: [...prev.waste],\n        stock: [...prev.stock]\n      };\n\n      // ... logic continues ...\n\n      let movedCards: Card[] = [];\n\n      // Remove from source\n      if (selectedCard.pile === 'waste') {\n        movedCards = [newGameState.waste.pop()!];\n      } else if (selectedCard.pile.startsWith('foundation')) {\n        const suit = selectedCard.pile.split('-')[1] as Suit;\n        movedCards = [newGameState.foundations[suit].pop()!];\n      } else if (selectedCard.pile.startsWith('tableau')) {\n        const colIdx = parseInt(selectedCard.pile.split('-')[1]);\n        const col = newGameState.tableau[colIdx];\n        movedCards = col.splice(selectedCard.index);\n\n        // Flip new top card if needed\n        if (col.length > 0 && !col[col.length - 1].faceUp) {\n          col[col.length - 1].faceUp = true;\n          newGameState.score += 5; // Points for flipping\n        }\n      }\n\n      // Add to target\n      if (typeof target === 'string') { // Foundation\n        const suit = target as Suit;\n        newGameState.foundations[suit].push(movedCards[0]);\n        newGameState.score += 10;\n      } else { // Tableau\n        newGameState.tableau[target].push(...movedCards);\n        newGameState.score += 5; // Points for Tableau move\n      }\n\n      newGameState.moves += 1;\n\n      // Check win\n      const foundationCount = Object.values(newGameState.foundations).reduce((acc, pile) => acc + pile.length, 0);\n      if (foundationCount === 52) {\n        newGameState.status = 'won';\n      }\n\n      return newGameState;\n    });\n    setSelectedCard(null);\n  };\n\n  const handleMoveAttempt = (targetColIndex: number) => {\n    if (!selectedCard) return;\n\n    const cardToMove = selectedCard.card;\n    if (canMoveToTableau(cardToMove, targetColIndex)) {\n      executeMove(targetColIndex);\n    } else {\n      setSelectedCard(null);\n    }\n  };\n\n  // Drag and drop handlers\n  const handleDragStart = (e: React.DragEvent, source: { pile: string, index: number }) => {\n    e.dataTransfer.setData('source', JSON.stringify(source));\n    e.dataTransfer.effectAllowed = 'move';\n  };\n\n  const handleDragOver = (e: React.DragEvent) => {\n    e.preventDefault();\n    e.dataTransfer.dropEffect = 'move';\n  };\n\n  const handleDrop = (e: React.DragEvent, target: string | number) => {\n    e.preventDefault();\n    const sourceData = e.dataTransfer.getData('source');\n    if (!sourceData) return;\n\n    const source = JSON.parse(sourceData) as { pile: string, index: number };\n\n    // We need to validate the move\n    // We need the card object from source. Since we only have pile/index, we need to look it up.\n    let card: Card;\n    if (source.pile === 'waste') {\n      if (gameState.waste.length === 0) return;\n      card = gameState.waste[gameState.waste.length - 1]; // Only top card of waste is draggable\n    } else if (source.pile.startsWith('tableau')) {\n      const colIdx = parseInt(source.pile.split('-')[1]);\n      card = gameState.tableau[colIdx][source.index];\n    } else if (source.pile.startsWith('foundation')) {\n      const suit = source.pile.split('-')[1] as Suit;\n      card = gameState.foundations[suit][gameState.foundations[suit].length - 1];\n    } else {\n      return;\n    }\n\n    if (typeof target === 'string') { // Foundation target\n      const suit = target as Suit;\n      // Can only drop single card on foundation\n      if (source.pile.startsWith('tableau')) {\n        const colIdx = parseInt(source.pile.split('-')[1]);\n        // Must be last card\n        if (source.index !== gameState.tableau[colIdx].length - 1) return;\n      }\n\n      if (canMoveToFoundation(card, suit)) {\n        directMove(source, suit);\n      }\n    } else { // Tableau target\n      // 'target' is colIndex\n      if (canMoveToTableau(card, target)) {\n        // We need a move function that takes 'target' as colIndex\n        // directMove only handles foundation targets currently.\n        executeDragMove(source, target);\n      }\n    }\n  };\n\n  const executeDragMove = (source: { pile: string, index: number }, targetColIndex: number) => {\n    saveHistory(); // Move recorded\n    setGameState(prev => {\n      const newGameState = {\n        ...prev,\n        tableau: prev.tableau.map(col => [...col]),\n        foundations: { ...prev.foundations },\n        waste: [...prev.waste],\n        stock: [...prev.stock]\n      };\n\n      let movedCards: Card[] = [];\n\n      // Remove from source\n      if (source.pile === 'waste') {\n        movedCards = [newGameState.waste.pop()!];\n      } else if (source.pile.startsWith('foundation')) {\n        const suit = source.pile.split('-')[1] as Suit;\n        movedCards = [newGameState.foundations[suit].pop()!];\n      } else if (source.pile.startsWith('tableau')) {\n        const colIdx = parseInt(source.pile.split('-')[1]);\n        const col = newGameState.tableau[colIdx];\n        movedCards = col.splice(source.index);\n\n        if (col.length > 0 && !col[col.length - 1].faceUp) {\n          col[col.length - 1].faceUp = true;\n          newGameState.score += 5;\n        }\n      }\n\n      // Add to target\n      newGameState.tableau[targetColIndex].push(...movedCards);\n      newGameState.score += 5;\n      newGameState.moves += 1;\n\n      return newGameState;\n    });\n  };\n\n\n\n  // Render Helpers\n  const renderCard = (card: Card, source: string, index: number, pileLength: number = 1) => {\n    const isSelected = selectedCard?.card.id === card.id;\n\n    // Dynamic Top Calculation\n    let topStyle = {};\n    if (source.startsWith('tableau')) {\n      // \"Squish\" logic\n      const maxExpandedHeight = 55; // vh, roughly allowing space for cards\n      const cardHeightVh = 18; // roughly the card height in vh\n\n      let spacing = 3.5; // default spacing in vh\n\n      const totalHeightNeeded = (pileLength - 1) * spacing + cardHeightVh;\n\n      if (totalHeightNeeded > maxExpandedHeight) {\n        // Squish!\n        // available space for offsets = maxExpandedHeight - cardHeightVh\n        // spacing = available / (pileLength - 1)\n        const availableSpace = maxExpandedHeight - cardHeightVh;\n        spacing = availableSpace / (pileLength - 1);\n      }\n\n      // Ensure minimum visibility for easier clicking/drag? (optional)\n      // spacing = Math.max(spacing, 1.5); \n\n      topStyle = { top: `${index * spacing}vh` };\n    }\n\n    return (\n      <div\n        key={card.id}\n        className={`card face-up ${card.color} ${isSelected ? 'selected' : ''}`}\n        style={topStyle}\n        draggable={true}\n        onDragStart={(e) => handleDragStart(e, { pile: source, index })}\n        onClick={(e) => {\n          e.stopPropagation();\n          handleCardClick(card, { pile: source, index });\n        }}\n        onDoubleClick={(e) => {\n          e.stopPropagation();\n          handleDoubleClick(card, { pile: source, index });\n        }}\n      >\n        <div className=\"card-top\">\n          <span className=\"card-value\">{card.rank}</span>\n          <span className=\"card-suit\">{getSuitSymbol(card.suit)}</span>\n        </div>\n        <div className=\"card-center\">\n          {getSuitSymbol(card.suit)}\n        </div>\n      </div>\n    );\n  };\n\n  return (\n    <div className=\"solitaire-wrapper\">\n      <div className=\"solitaire-header-controls\">\n        <h1 className=\"solitaire-title\">Classic Solitaire</h1>\n        <div className=\"game-stats-row\">\n          <div className=\"stat-box\">Score: {gameState.score}</div>\n          <div className=\"stat-box\">Moves: {gameState.moves}</div>\n          <button\n            className=\"new-game-btn\"\n            onClick={undo}\n            disabled={history.length === 0}\n            style={{ opacity: history.length === 0 ? 0.5 : 1 }}\n          >\n            Undo\n          </button>\n          <button\n            className=\"new-game-btn\"\n            onClick={redo}\n            disabled={future.length === 0}\n            style={{ opacity: future.length === 0 ? 0.5 : 1 }}\n          >\n            Redo\n          </button>\n          <button className=\"new-game-btn\" onClick={initializeGame}>New Game</button>\n        </div>\n      </div>\n\n      <div className=\"solitaire-container\">\n        {isDealing && (\n          <div className=\"win-message\" style={{ zIndex: 3000 }}>\n            <h2>Dealing...</h2>\n            <p>Finding a winnable hand</p>\n          </div>\n        )}\n        <div className=\"solitaire-board\">\n          <div className=\"top-section\">\n            <div className=\"deck-area\">\n              <div className=\"card-pile\" onClick={handleStockClick}>\n                {gameState.stock.length > 0 ? (\n                  <div className=\"card card-back\"></div>\n                ) : (\n                  <div className=\"card-placeholder\">↺</div>\n                )}\n              </div>\n              <div className=\"card-pile\">\n                {gameState.waste.length > 0 &&\n                  renderCard(gameState.waste[gameState.waste.length - 1], 'waste', gameState.waste.length - 1)\n                }\n              </div>\n            </div>\n\n            <div className=\"foundation-area\">\n              {SUITS.map(suit => (\n                <div\n                  key={suit}\n                  className=\"card-pile\"\n                  onClick={() => handleFoundationClick(suit)}\n                  onDragOver={handleDragOver}\n                  onDrop={(e) => handleDrop(e, suit)}\n                >\n                  <div className=\"card-placeholder\" style={{ color: getSuitColor(suit) === 'red' ? '#ffcccc' : '#e0e0e0' }}>\n                    {getSuitSymbol(suit)}\n                  </div>\n                  {gameState.foundations[suit].map((card, idx) => (\n                    <div key={card.id} className=\"card-stack-item\">\n                      {renderCard(card, `foundation-${suit}`, idx)}\n                    </div>\n                  ))}\n                </div>\n              ))}\n            </div>\n          </div>\n\n          <div className=\"tableau-area\">\n            {gameState.tableau.map((column, i) => (\n              <div\n                key={i}\n                className=\"tableau-column\"\n                onClick={() => handleEmptyTableauClick(i)}\n                onDragOver={handleDragOver}\n                onDrop={(e) => handleDrop(e, i)}\n              >\n                {column.map((card, idx) => (\n                  card.faceUp ?\n                    renderCard(card, `tableau-${i}`, idx, column.length) :\n                    <div\n                      key={card.id}\n                      className=\"card card-back\"\n                      style={{ top: `${idx * 2}vh`, position: 'absolute' }} // Compact back-of-cards\n                    ></div>\n                ))}\n              </div>\n            ))}\n          </div>\n        </div>\n\n        {gameState.status === 'won' && (\n          <div className=\"win-message\">\n            <h2>Congratulations!</h2>\n            <p>You won!</p>\n            <button className=\"new-game-btn\" onClick={initializeGame}>Play Again</button>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default Solitaire;\n"],"file":"assets/Solitaire-C39msR0P.js"}