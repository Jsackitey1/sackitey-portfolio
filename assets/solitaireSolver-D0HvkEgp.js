import{S as y,g as k}from"./Solitaire-C39msR0P.js";import"./index-Do4ognXd.js";import"./motion-3Unlpoja.js";import"./vendor-_uqhELNW.js";const U=a=>({stock:[...a.stock],waste:[...a.waste],foundations:{hearts:[...a.foundations.hearts],diamonds:[...a.foundations.diamonds],clubs:[...a.foundations.clubs],spades:[...a.foundations.spades]},tableau:a.tableau.map(h=>h.map(r=>({...r}))),score:a.score,moves:a.moves,status:a.status}),S=a=>{const h=y.map(c=>a.foundations[c].length).join(","),r=a.stock.length,I=a.waste.length>0?a.waste[a.waste.length-1].id:"x",p=a.tableau.map(c=>{if(c.length===0)return"e";const f=c[c.length-1],w=c.findIndex(v=>v.faceUp);return`${f.id}:${w}`}).join("|");return`${h}|${r}|${I}|${p}`},C=a=>{const h=Array(7).fill([]).map(()=>[]);let r=0;for(let e=0;e<7;e++)for(let g=0;g<=e;g++){const b={...a[r],faceUp:g===e};h[e].push(b),r++}const p={stock:a.slice(r).map(e=>({...e,faceUp:!1})),waste:[],foundations:{hearts:[],diamonds:[],clubs:[],spades:[]},tableau:h,score:0,moves:0,status:"playing"},c=[p],f=new Set;f.add(S(p));let w=0;const v=5e3;for(;c.length>0&&w<v;){const e=c.pop();if(w++,y.reduce((t,n)=>t+e.foundations[n].length,0)===52)return!0;const b=[];for(let t=0;t<=7;t++){let n,s="",i=-1;if(t<7){const o=e.tableau[t];o.length>0&&(n=o[o.length-1],s="tableau",i=t)}else e.waste.length>0&&(n=e.waste[e.waste.length-1],s="waste");if(n){const o=e.foundations[n.suit];let d=!1;if(o.length===0)n.rank==="A"&&(d=!0);else{const l=o[o.length-1];k(n.rank)===k(l.rank)+1&&(d=!0)}if(d){const l=U(e);let u;s==="tableau"?(u=l.tableau[i].pop(),l.tableau[i].length>0&&(l.tableau[i][l.tableau[i].length-1].faceUp=!0)):u=l.waste.pop(),l.foundations[n.suit].push(u);const m=S(l);f.has(m)||(f.add(m),b.push(l))}}}const x=[];if(e.waste.length>0&&x.push({type:"waste",card:e.waste[e.waste.length-1]}),e.tableau.forEach((t,n)=>{t.length>0&&t.forEach((s,i)=>{s.faceUp&&x.push({type:"tableau",colIdx:n,card:s,substack:t.slice(i)})})}),e.tableau.forEach((t,n)=>{x.forEach(s=>{if(s.type==="tableau"&&s.colIdx===n)return;let i=!1;if(t.length===0)s.card.rank==="K"&&(i=!0);else{const o=t[t.length-1];o.color!==s.card.color&&k(o.rank)===k(s.card.rank)+1&&(i=!0)}if(i){const o=U(e);let d=[];if(s.type==="waste")d=[o.waste.pop()];else{const u=o.tableau[s.colIdx],m=u.findIndex(E=>E.id===s.card.id);d=u.splice(m),u.length>0&&(u[u.length-1].faceUp=!0)}o.tableau[n].push(...d);const l=S(o);f.has(l)||(f.add(l),c.push(o))}})}),e.stock.length>0||e.waste.length>0){const t=U(e);if(t.stock.length===0)t.stock=t.waste.reverse().map(s=>({...s,faceUp:!1})),t.waste=[];else{const s=t.stock.shift();s.faceUp=!0,t.waste.push(s)}const n=S(t);f.has(n)||(f.add(n),c.push(t))}b.forEach(t=>c.push(t))}return!1};export{C as isSolvable};
//# sourceMappingURL=solitaireSolver-D0HvkEgp.js.map
