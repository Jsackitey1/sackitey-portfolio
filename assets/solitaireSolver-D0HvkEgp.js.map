{"version":3,"file":"solitaireSolver-D0HvkEgp.js","sources":["../../src/utils/solitaireSolver.ts"],"sourcesContent":["import { Card, GameState, SUITS, getCardValue } from '../types/solitaire';\n\n// Helper to clone state deeply\nconst cloneState = (state: GameState): GameState => ({\n    stock: [...state.stock],\n    waste: [...state.waste],\n    foundations: {\n        hearts: [...state.foundations.hearts],\n        diamonds: [...state.foundations.diamonds],\n        clubs: [...state.foundations.clubs],\n        spades: [...state.foundations.spades]\n    },\n    tableau: state.tableau.map(col => col.map(c => ({ ...c }))), // Deep clone cards? No, card objects are immutable enough, but array structure matters.\n    // Actually card objects have `faceUp` which changes. So yes, clone cards.\n    score: state.score,\n    moves: state.moves,\n    status: state.status\n});\n\nconst hashState = (state: GameState): string => {\n    // Create a minimal string representation for visited set\n    // Order: Foundations lengths, Stock length, Waste top, Tableau(faceUps info)\n    const f = SUITS.map(s => state.foundations[s].length).join(',');\n    const s = state.stock.length;\n    const w = state.waste.length > 0 ? state.waste[state.waste.length - 1].id : 'x';\n    const t = state.tableau.map(col => {\n        if (col.length === 0) return 'e';\n        // ID of top card + index of first faceup card\n        const top = col[col.length - 1];\n        const firstFaceUp = col.findIndex(c => c.faceUp);\n        return `${top.id}:${firstFaceUp}`;\n    }).join('|');\n    return `${f}|${s}|${w}|${t}`;\n};\n\n// Simplified simulator for checking solvability\n// Returns true if solvable within N steps\nexport const isSolvable = (deck: Card[]): boolean => {\n    // 1. Setup Initial State\n    const tableau: Card[][] = Array(7).fill([]).map(() => []);\n    let deckIndex = 0;\n    for (let i = 0; i < 7; i++) {\n        for (let j = 0; j <= i; j++) {\n            const card = { ...deck[deckIndex], faceUp: j === i }; // Only last one face up\n            tableau[i].push(card);\n            deckIndex++;\n        }\n    }\n    const stock = deck.slice(deckIndex).map(c => ({ ...c, faceUp: false }));\n\n    const initialState: GameState = {\n        stock,\n        waste: [],\n        foundations: { hearts: [], diamonds: [], clubs: [], spades: [] },\n        tableau,\n        score: 0,\n        moves: 0,\n        status: 'playing'\n    };\n\n    const queue: GameState[] = [initialState];\n    const visited = new Set<string>();\n    visited.add(hashState(initialState));\n\n    let steps = 0;\n    const MAX_STEPS = 5000; // Hard limit for responsiveness\n\n    while (queue.length > 0 && steps < MAX_STEPS) {\n        // DFS or BFS? BFS finds shortest, DFS is deeper.\n        // For solvability, we just need ANY path.\n        // Heuristic: Prefer moves that reveal cards or move to foundation.\n        // Let's use a \"Priority Queue\" approach by sorting available moves? \n        // Or just simple greedy DFS with backtracking effectively (using stack).\n        // Using simple stack (pop) = DFS.\n\n        const currentState = queue.pop()!;\n        steps++;\n\n        // Check Win\n        const foundationCount = SUITS.reduce((sum, s) => sum + currentState.foundations[s].length, 0);\n        if (foundationCount === 52) return true; // Found a win!\n\n        // Optimization: If foundation count is high (e.g. > 45), assume winnable? \n        // Risky, but speeds up. Let's stick to true win for now.\n\n        const nextStates: GameState[] = [];\n\n        // --- Generate Moves ---\n\n        // 1. Move to Foundation (Auto-win check logic often moves these first)\n        // From Tableau\n        for (let isTableau = 0; isTableau <= 7; isTableau++) { // 0-6 are tableau cols, 7 is waste \n            // Simplified iteration\n            let card: Card | undefined;\n            let fromPileType = '';\n            let fromIdx = -1;\n\n            if (isTableau < 7) {\n                const col = currentState.tableau[isTableau];\n                if (col.length > 0) {\n                    card = col[col.length - 1];\n                    fromPileType = 'tableau';\n                    fromIdx = isTableau;\n                }\n            } else {\n                // Waste\n                if (currentState.waste.length > 0) {\n                    card = currentState.waste[currentState.waste.length - 1];\n                    fromPileType = 'waste';\n                }\n            }\n\n            if (card) {\n                // Can move to foundation?\n                const pile = currentState.foundations[card.suit];\n                let canMove = false;\n                if (pile.length === 0) {\n                    if (card.rank === 'A') canMove = true;\n                } else {\n                    const top = pile[pile.length - 1];\n                    if (getCardValue(card.rank) === getCardValue(top.rank) + 1) canMove = true;\n                }\n\n                if (canMove) {\n                    const newState = cloneState(currentState);\n                    // Apply Move\n                    let movedCard: Card;\n                    if (fromPileType === 'tableau') {\n                        movedCard = newState.tableau[fromIdx].pop()!;\n                        if (newState.tableau[fromIdx].length > 0) {\n                            newState.tableau[fromIdx][newState.tableau[fromIdx].length - 1].faceUp = true;\n                        }\n                    } else {\n                        movedCard = newState.waste.pop()!;\n                    }\n                    newState.foundations[card.suit].push(movedCard);\n\n                    const h = hashState(newState);\n                    if (!visited.has(h)) {\n                        visited.add(h);\n                        nextStates.push(newState); // High priority\n                    }\n                }\n            }\n        }\n\n        // 2. Tableau to Tableau\n        // Try moving from any tableau stack (face up part) or waste to another tableau column\n        // We only care about moving the *base* of a stack to a target.\n        // Moving substacks is equivalent to moving the base card.\n\n        // Sources: Waste, Tableau (face up cards)\n        const sources: { type: 'waste' | 'tableau', colIdx?: number, card: Card, substack?: Card[] }[] = [];\n\n        if (currentState.waste.length > 0) {\n            sources.push({ type: 'waste', card: currentState.waste[currentState.waste.length - 1] });\n        }\n\n        currentState.tableau.forEach((col, idx) => {\n            if (col.length > 0) {\n                // We can move any face-up card and the cards above it\n                // Optimally, we usually only want to move the valid substack that helps?\n                // Let's just consider moving the specific meaningful chunks.\n                // Simple solver: Iterate all face up cards.\n                col.forEach((c, cIdx) => {\n                    if (c.faceUp) {\n                        sources.push({ type: 'tableau', colIdx: idx, card: c, substack: col.slice(cIdx) });\n                    }\n                });\n            }\n        });\n\n        // Targets: Tableau columns\n        currentState.tableau.forEach((targetCol, targetIdx) => {\n            sources.forEach(source => {\n                // Cannot move to self\n                if (source.type === 'tableau' && source.colIdx === targetIdx) return;\n\n                // Helper check\n                let valid = false;\n                if (targetCol.length === 0) {\n                    if (source.card.rank === 'K') valid = true;\n                } else {\n                    const top = targetCol[targetCol.length - 1];\n                    if (top.color !== source.card.color && getCardValue(top.rank) === getCardValue(source.card.rank) + 1) {\n                        valid = true;\n                    }\n                }\n\n                if (valid) {\n                    const newState = cloneState(currentState);\n\n                    // Execute move\n                    let cardsToMove: Card[] = [];\n                    if (source.type === 'waste') {\n                        cardsToMove = [newState.waste.pop()!];\n                    } else {\n                        // Tableau\n                        const sCol = newState.tableau[source.colIdx!];\n                        const cutIdx = sCol.findIndex(c => c.id === source.card.id); // Find index relative to new cloned state\n                        cardsToMove = sCol.splice(cutIdx);\n                        // Reveal next\n                        if (sCol.length > 0) sCol[sCol.length - 1].faceUp = true;\n                    }\n\n                    newState.tableau[targetIdx].push(...cardsToMove);\n\n                    const h = hashState(newState);\n                    if (!visited.has(h)) {\n                        visited.add(h);\n                        queue.push(newState); // Normal priority\n                    }\n                }\n            });\n        });\n\n        // 3. Stock to Waste\n        if (currentState.stock.length > 0 || currentState.waste.length > 0) {\n            // If stock empty, recycle waste\n            const newState = cloneState(currentState);\n            if (newState.stock.length === 0) {\n                newState.stock = newState.waste.reverse().map(c => ({ ...c, faceUp: false }));\n                newState.waste = [];\n            } else {\n                const c = newState.stock.shift()!;\n                c.faceUp = true;\n                newState.waste.push(c);\n            }\n\n            const h = hashState(newState);\n            if (!visited.has(h)) {\n                visited.add(h);\n                queue.push(newState); // Low priority\n                // Note: Logic allows recycle, but check hash to prevent infinite loops of just flipping stock/waste\n            }\n        }\n\n        // Add priority states (Foundation moves) to queue\n        // Since using push/pop (Stack), pushing Foundation moves LAST makes them processed FIRST (DFS).\n        nextStates.forEach(s => queue.push(s));\n    }\n\n    // Timeout / limit reached\n    return false;\n};\n"],"names":["cloneState","state","col","c","hashState","f","SUITS","s","w","t","top","firstFaceUp","isSolvable","deck","tableau","deckIndex","i","j","card","initialState","queue","visited","steps","MAX_STEPS","currentState","sum","nextStates","isTableau","fromPileType","fromIdx","pile","canMove","getCardValue","newState","movedCard","h","sources","idx","cIdx","targetCol","targetIdx","source","valid","cardsToMove","sCol","cutIdx"],"mappings":"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"}